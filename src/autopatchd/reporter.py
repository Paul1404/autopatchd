"""
Email reporting functionality
"""

import smtplib
import os
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
import logging
import socket

from .patcher import PatchResult


class Reporter:
    """Handles email reporting of patch results"""
    
    def __init__(self, config):
        self.config = config
    
    def send_report(self, result: PatchResult, dry_run: bool = False):
        """Send email report of patch results"""
        if not self.config.email.to_addresses:
            logging.info("No email addresses configured, skipping report")
            return
        
        try:
            subject = self._generate_subject(result, dry_run)
            body = self._generate_body(result, dry_run)
            
            self._send_email(subject, body)
            logging.info("Email report sent successfully")
            
        except Exception as e:
            logging.error(f"Failed to send email report: {e}")
    
    def _generate_subject(self, result: PatchResult, dry_run: bool) -> str:
        """Generate email subject line"""
        hostname = socket.gethostname()
        prefix = "DRY-RUN" if dry_run else "PATCH"
        status = "SUCCESS" if result.success else "FAILED"
        
        if dry_run:
            if result.updates_available:
                return f"[{prefix}] {hostname} - {len(result.updates_available)} updates available"
            else:
                return f"[{prefix}] {hostname} - No updates available"
        else:
            if result.updates_installed:
                return f"[{prefix}] {hostname} - {len(result.updates_installed)} updates installed - {status}"
            else:
                return f"[{prefix}] {hostname} - No updates - {status}"
    
    def _generate_body(self, result: PatchResult, dry_run: bool) -> str:
        """Generate email body"""
        hostname = socket.gethostname()
        
        body = f"""autopatchd Report
{'=' * 50}

Host: {hostname}
Timestamp: {result.timestamp}
Mode: {result.mode}
Type: {'Dry-run' if dry_run else 'Live run'}
Success: {result.success}

"""
        
        if result.error:
            body += f"Error: {result.error}\n\n"
        
        # Updates section
        if result.updates_available:
            body += f"Updates Available ({len(result.updates_available)}):\n"
            body += "-" * 30 + "\n"
            for pkg in result.updates_available:
                body += f"  • {pkg}\n"
            body += "\n"
        
        if result.updates_installed:
            body += f"Updates Installed ({len(result.updates_installed)}):\n"
            body += "-" * 30 + "\n"
            for pkg in result.updates_installed:
                body += f"  • {pkg}\n"
            body += "\n"
        
        if result.reboot_required:
            body += "⚠️  REBOOT REQUIRED\n"
            body += f"Reboot policy: {self.config.patching.reboot}\n\n"
        
        # Full output
        body += "Full Output:\n"
        body += "=" * 20 + "\n"
        body += result.output
        body += "\n\n"
        
        body += f"Generated by autopatchd on {hostname}\n"
        
        return body
    
    def _send_email(self, subject: str, body: str):
        """Send email via SMTP"""
        # Load SMTP credentials
        smtp_user, smtp_pass = self._load_smtp_credentials()
        
        # Create message
        msg = MIMEMultipart()
        msg['From'] = self.config.email.from_address
        msg['To'] = ', '.join(self.config.email.to_addresses)
        msg['Subject'] = subject
        
        msg.attach(MIMEText(body, 'plain'))
        
        # Send email
        with smtplib.SMTP(self.config.email.smtp_server, self.config.email.smtp_port) as server:
            if self.config.email.use_tls:
                server.starttls()
            
            if smtp_user and smtp_pass:
                server.login(smtp_user, smtp_pass)
            
            server.send_message(msg)
    
    def _load_smtp_credentials(self):
        """Load SMTP credentials from systemd credentials or file"""
        # Try systemd credentials first
        cred_file = "/run/credentials/autopatchd.service/smtp-password.cred"
        if os.path.exists(cred_file):
            return self._parse_credentials(cred_file)
        
        # Fallback to regular file
        cred_file = "/etc/autopatchd/smtp-password.cred"
        if os.path.exists(cred_file):
            return self._parse_credentials(cred_file)
        
        logging.warning("No SMTP credentials found")
        return None, None
    
    def _parse_credentials(self, cred_file: str):
        """Parse credentials file"""
        try:
            with open(cred_file, 'r') as f:
                content = f.read().strip()
            
            smtp_user = None
            smtp_pass = None
            
            for line in content.split('\n'):
                if line.startswith('SMTP_USER='):
                    smtp_user = line.split('=', 1)[1]
                elif line.startswith('SMTP_PASS='):
                    smtp_pass = line.split('=', 1)[1]
            
            return smtp_user, smtp_pass
            
        except Exception as e:
            logging.error(f"Failed to parse credentials: {e}")
            return None, None